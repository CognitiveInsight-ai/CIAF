"""
Merkle tree implementation for tamper-evident data integrity verification.

This module provides Merkle tree functionality used in training snapshots
to prove what data was used to train a specific model version.
"""

from .crypto import sha256_hash


class MerkleTree:
    """
    Implements a Merkle Tree for tamper-evident data integrity verification.
    Used in Training Snapshots to prove what data trained the model.
    """
    
    def __init__(self, leaves: list[str]):
        """
        Initializes a Merkle Tree with a list of data hashes (leaves).
        
        Args:
            leaves: A list of SHA256 hashes of the data items.
            
        Raises:
            ValueError: If no leaves are provided.
        """
        if not leaves:
            raise ValueError("Merkle tree must have at least one leaf.")
        self.leaves = leaves
        self.tree = self._build_tree(leaves)
        self.root = self.tree[-1][0] if self.tree else None

    def _hash_pair(self, hash1: str, hash2: str) -> str:
        """Hashes two child hashes together."""
        return sha256_hash((hash1 + hash2).encode('utf-8'))

    def _build_tree(self, leaves: list[str]) -> list[list[str]]:
        """Recursively builds the Merkle tree."""
        tree = [leaves]
        current_level = leaves
        while len(current_level) > 1:
            next_level = []
            for i in range(0, len(current_level), 2):
                h1 = current_level[i]
                h2 = current_level[i+1] if i+1 < len(current_level) else h1  # Duplicate last if odd number
                next_level.append(self._hash_pair(h1, h2))
            tree.append(next_level)
            current_level = next_level
        return tree

    def get_root(self) -> str:
        """Returns the Merkle root hash."""
        return self.root

    def get_proof(self, leaf_hash: str) -> list[tuple[str, str]]:
        """
        Generates a Merkle proof for a given leaf hash.
        
        Args:
            leaf_hash: The hash of the leaf for which to generate the proof.
            
        Returns:
            A list of tuples (hash, position), where position is 'left' or 'right'.
            Returns an empty list if the leaf is not found or is the root itself.
        """
        proof = []
        try:
            leaf_index = self.leaves.index(leaf_hash)
        except ValueError:
            return []  # Leaf not found

        # If it's a single-leaf tree, the leaf is the root, no proof needed
        if len(self.leaves) == 1 and self.leaves[0] == leaf_hash:
            return []

        current_hash = leaf_hash
        for level_idx in range(len(self.tree) - 1):  # Iterate through levels from leaves up to root's parent
            current_level = self.tree[level_idx]
            
            # Determine if current_hash is a left or right child based on its index
            is_right_child = (leaf_index % 2 != 0)
            sibling_index = leaf_index - 1 if is_right_child else leaf_index + 1

            # Handle the case where the last element is duplicated for an odd number of nodes at this level
            if sibling_index >= len(current_level):
                # This means current_hash is the last element and it was duplicated.
                # Its sibling is itself.
                sibling_hash = current_level[leaf_index]  # Sibling is the element itself
                proof.append((sibling_hash, 'left' if is_right_child else 'right'))  # Position is relative to current_hash
            else:
                sibling_hash = current_level[sibling_index]
                proof.append((sibling_hash, 'left' if is_right_child else 'right'))

            leaf_index //= 2  # Move up to the parent node's index

        return proof

    @staticmethod
    def verify_proof(leaf_hash: str, root_hash: str, proof: list[tuple[str, str]]) -> bool:
        """
        Verifies a Merkle proof for a given leaf hash against a root hash.
        
        Args:
            leaf_hash: The hash of the leaf to verify.
            root_hash: The expected Merkle root hash.
            proof: The Merkle proof generated by get_proof.
            
        Returns:
            True if the leaf is part of the tree and the proof is valid, False otherwise.
        """
        current_hash = leaf_hash
        # Special case for a single-leaf tree where the leaf is the root
        if not proof and current_hash == root_hash: 
            return True

        for sibling_hash, position in proof:
            if position == 'left':
                current_hash = sha256_hash((sibling_hash + current_hash).encode('utf-8'))
            else:  # position == 'right'
                current_hash = sha256_hash((current_hash + sibling_hash).encode('utf-8'))
        return current_hash == root_hash
